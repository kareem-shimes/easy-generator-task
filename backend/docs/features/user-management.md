# User Management

## Overview

This document describes user management features including user data handling, validation, profile management, and data operations.

## User Data Model

### User Schema

```typescript
interface User {
  _id: string;              // MongoDB ObjectId
  email: string;            // Unique, lowercase
  name: string;             // Display name
  password: string;         // Bcrypt hash (excluded from queries)
  createdAt: Date;          // Account creation timestamp
  updatedAt: Date;          // Last update timestamp
}
```

### Field Specifications

**_id**:
- Type: MongoDB ObjectId
- Auto-generated by MongoDB
- Unique identifier for the user

**email**:
- Type: String
- Required: Yes
- Unique: Yes
- Validation: Valid email format
- Transformation: Lowercase, trimmed
- Indexed: Yes

**name**:
- Type: String
- Required: Yes
- Minimum length: 3 characters
- Transformation: Trimmed
- Example: "John Doe"

**password**:
- Type: String
- Required: Yes
- Storage: Bcrypt hash only (salt rounds: 10)
- Available in database for authentication purposes
- Never returned in API responses (excluded via UserEntity transformation)

**createdAt**:
- Type: Date
- Auto-generated on creation
- Immutable

**updatedAt**:
- Type: Date
- Auto-updated on modifications
- Tracked automatically by Mongoose

## User Operations

### Get Current User Profile

Retrieve the authenticated user's profile information.

**Endpoint**: `GET /users/me`

**Authentication**: Required (JWT)

**Request Headers**:
```
Authorization: Bearer <jwt_token>
```

**Success Response** (200):
```json
{
  "_id": "507f1f77bcf86cd799439011",
  "email": "user@example.com",
  "name": "John Doe",
  "createdAt": "2025-10-29T10:30:00.000Z",
  "updatedAt": "2025-10-29T10:30:00.000Z"
}
```

**Error Response** (401):
```json
{
  "statusCode": 401,
  "message": "Unauthorized"
}
```

**Implementation**:
```typescript
@UseGuards(JwtAuthGuard)
@Get('profile')
async getProfile(@Request() req) {
  return this.usersService.findById(req.user.userId);
}
```

### Update User Profile

Update the authenticated user's profile information.

**Endpoint**: `PATCH /users/me`

**Authentication**: Required (JWT)

**Request Body** (all fields optional):
```json
{
  "name": "John Smith"
}
```

**Validation Rules**:
- `name`: Minimum 3 characters (if provided)

**Success Response** (200):
```json
{
  "_id": "507f1f77bcf86cd799439011",
  "email": "user@example.com",
  "name": "John Smith",
  "createdAt": "2025-10-29T10:30:00.000Z",
  "updatedAt": "2025-10-29T16:45:00.000Z"
}
```

**Error Responses**:

*400 Bad Request* - Validation error:
```json
{
  "statusCode": 400,
  "message": ["name must be at least 3 characters"],
  "error": "Bad Request"
}
```

*401 Unauthorized* - Not authenticated:
```json
{
  "statusCode": 401,
  "message": "Unauthorized"
}
```

**Implementation**:
```typescript
@UseGuards(JwtAuthGuard)
@Patch('profile')
async updateProfile(
  @Request() req,
  @Body() updateDto: UpdateUserDto,
) {
  return this.usersService.update(req.user.userId, updateDto);
}
```

## Data Transfer Objects (DTOs)

### Update User DTO

```typescript
export class UpdateUserDto {
  @IsString()
  @MinLength(3)
  @IsOptional()
  name?: string;
}
```

### User Response DTO

```typescript
export class UserResponseDto {
  @Expose()
  _id: string;

  @Expose()
  email: string;

  @Expose()
  name: string;

  @Expose()
  createdAt: Date;

  @Expose()
  updatedAt: Date;
}
```

**Note**: Password is always excluded from responses.

## Data Validation

### Email Validation

**Rules**:
- Must be valid email format
- Must be unique across all users
- Automatically converted to lowercase
- Whitespace trimmed

**Validation Decorator**:
```typescript
@IsEmail()
@IsNotEmpty()
email: string;
```

**Regex Pattern**:
```regex
/^\S+@\S+\.\S+$/
```

**Valid Examples**:
- `user@example.com`
- `john.doe@company.co.uk`
- `test123@subdomain.example.org`

**Invalid Examples**:
- `user@` (incomplete)
- `@example.com` (missing local part)
- `user @example.com` (whitespace)
- `user` (no @ symbol)

### Name Validation

**Rules**:
- Minimum 3 characters
- Whitespace trimmed
- Required field

**Validation Decorator**:
```typescript
@IsString()
@MinLength(3)
@IsNotEmpty()
name: string;
```

**Valid Examples**:
- `John`
- `Jane Doe`
- `Dr. Smith`

**Invalid Examples**:
- `JD` (too short)
- `` (empty)
- `  ` (only whitespace)

## Data Sanitization

### Automatic Transformations

**Email**:
```typescript
// Input: "User@Example.COM  "
// Stored: "user@example.com"
```

**Name**:
```typescript
// Input: "  John Doe  "
// Stored: "John Doe"
```

### Schema-Level Sanitization

```typescript
const UserSchema = new Schema({
  email: {
    type: String,
    lowercase: true,
    trim: true,
  },
  name: {
    type: String,
    trim: true,
  },
});
```

## Security Measures

### Password Protection

**Storage**:
- Passwords are hashed with bcrypt before storage
- Salt rounds: 10
- Never stored in plain text
- Never returned in API responses (via UserEntity transformation)

**Password Hashing**:
```typescript
// In UsersService.create()
const hashedPassword = await bcrypt.hash(createUserDto.password, 10);
const createdUser = new this.userModel({
  ...createUserDto,
  password: hashedPassword,
});
return createdUser.save();
```

**Response Transformation**:
```typescript
// Password is excluded from API responses via UserEntity
toUserEntity(user: UserDocument): UserEntity {
  return new UserEntity({
    _id: (user._id as Types.ObjectId).toString(),
    email: user.email,
    name: user.name,
    createdAt: user.createdAt,
    updatedAt: user.updatedAt,
    // password is NOT included
  });
}
```

### Authorization

**Self-Access Only**:
- Users can only access/update their own profile
- User ID extracted from JWT token
- No need for manual authorization checks

**Implementation**:
```typescript
// User ID comes from authenticated token
const userId = req.user.userId;

// User can only access their own data
return this.usersService.findById(userId);
```

## Error Handling

### Common Errors

**Duplicate Email** (409):
```json
{
  "statusCode": 409,
  "message": "User with this email already exists",
  "error": "Conflict"
}
```

**User Not Found** (404):
```json
{
  "statusCode": 404,
  "message": "User not found",
  "error": "Not Found"
}
```

**Validation Error** (400):
```json
{
  "statusCode": 400,
  "message": [
    "name must be at least 3 characters",
    "email must be a valid email"
  ],
  "error": "Bad Request"
}
```

**Unauthorized** (401):
```json
{
  "statusCode": 401,
  "message": "Unauthorized"
}
```

## Database Operations

### Create User

```typescript
async create(createUserDto: CreateUserDto): Promise<User> {
  const existingUser = await this.userModel.findOne({
    email: createUserDto.email,
  });

  if (existingUser) {
    throw new ConflictException('User with this email already exists');
  }

  const user = new this.userModel(createUserDto);
  return user.save();
}
```

### Find User by Email

```typescript
async findByEmail(email: string): Promise<User | null> {
  return this.userModel
    .findOne({ email: email.toLowerCase() })
    .exec();
  // Password is available in the document for authentication
  // but excluded from API responses via toUserEntity()
}
```

### Find User by ID

```typescript
async findById(id: string): Promise<User> {
  const user = await this.userModel.findById(id).exec();
  
  if (!user) {
    throw new NotFoundException('User not found');
  }
  
  return user;
}
```

### Update User

```typescript
async update(id: string, updateDto: UpdateUserDto): Promise<User> {
  const user = await this.userModel
    .findByIdAndUpdate(id, updateDto, { new: true })
    .exec();
  
  if (!user) {
    throw new NotFoundException('User not found');
  }
  
  return user;
}
```

## Client Integration Examples

### Get Profile

```typescript
const getProfile = async (token: string) => {
  const response = await fetch('http://localhost:3000/users/me', {
    headers: {
      'Authorization': `Bearer ${token}`,
    },
  });

  if (!response.ok) {
    throw new Error('Failed to fetch profile');
  }

  return await response.json();
};
```

### Update Profile

```typescript
const updateProfile = async (token: string, name: string) => {
  const response = await fetch('http://localhost:3000/users/me', {
    method: 'PATCH',
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ name }),
  });

  if (!response.ok) {
    throw new Error('Failed to update profile');
  }

  return await response.json();
};
```

## Testing

### Unit Tests

```typescript
describe('UsersService', () => {
  it('should find user by id', async () => {
    const userId = 'test-user-id';
    const mockUser = {
      _id: userId,
      email: 'test@test.com',
      name: 'Test User',
    };

    jest.spyOn(userModel, 'findById').mockReturnValue({
      exec: jest.fn().mockResolvedValue(mockUser),
    } as any);

    const result = await service.findById(userId);
    expect(result).toEqual(mockUser);
  });

  it('should throw NotFoundException when user not found', async () => {
    jest.spyOn(userModel, 'findById').mockReturnValue({
      exec: jest.fn().mockResolvedValue(null),
    } as any);

    await expect(service.findById('invalid-id')).rejects.toThrow(
      NotFoundException,
    );
  });
});
```

### E2E Tests

```typescript
describe('User Profile (e2e)', () => {
  let token: string;

  beforeAll(async () => {
    // Sign up to get token
    const response = await request(app.getHttpServer())
      .post('/auth/signup')
      .send({
        email: 'test@test.com',
        name: 'Test User',
        password: 'Test123!',
      });

    token = response.body.access_token;
  });

  it('/users/me (GET)', () => {
    return request(app.getHttpServer())
      .get('/users/me')
      .set('Authorization', `Bearer ${token}`)
      .expect(200)
      .expect((res) => {
        expect(res.body).toHaveProperty('email', 'test@test.com');
        expect(res.body).toHaveProperty('name', 'Test User');
        expect(res.body).not.toHaveProperty('password');
      });
  });

  it('/users/me (PATCH)', () => {
    return request(app.getHttpServer())
      .patch('/users/me')
      .set('Authorization', `Bearer ${token}`)
      .send({ name: 'Updated Name' })
      .expect(200)
      .expect((res) => {
        expect(res.body).toHaveProperty('name', 'Updated Name');
      });
  });
});
```

## Best Practices

### Data Privacy

1. **Never expose passwords**: Always exclude from responses
2. **Minimal data exposure**: Only return necessary fields
3. **Self-access only**: Users access only their own data
4. **Audit trails**: Log data access and modifications

### Data Integrity

1. **Validate all inputs**: Use DTOs with validation decorators
2. **Sanitize data**: Trim whitespace, normalize case
3. **Unique constraints**: Email uniqueness enforced
4. **Type safety**: TypeScript interfaces and schemas

### Performance

1. **Indexed fields**: Email field is indexed for fast lookups
2. **Selective queries**: Exclude password by default
3. **Efficient updates**: Use `findByIdAndUpdate`
4. **Avoid N+1 queries**: Use proper query design

## Future Enhancements

Potential improvements:

1. **Profile Picture**: Upload and manage user avatars
2. **Email Change**: Allow users to update email with verification
3. **Password Change**: Secure password update flow
4. **Account Deletion**: Soft or hard delete with confirmation
5. **User Preferences**: Store user settings and preferences
6. **Last Login Tracking**: Track user activity
7. **Account Status**: Active, suspended, deleted states
8. **User Roles**: Admin, moderator, user roles
9. **Multi-profile**: Support for multiple profiles per account
10. **Data Export**: GDPR compliance - export user data
